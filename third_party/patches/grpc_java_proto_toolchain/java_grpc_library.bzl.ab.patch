--- a/java_grpc_library.bzl	2026-01-26 17:49:40
+++ b/java_grpc_library.bzl	2026-01-26 17:49:26
@@ -1,56 +1,94 @@
 """Build rule for java_grpc_library."""
 load("@rules_proto//proto:defs.bzl", "ProtoInfo")
 load("@rules_java//java:defs.bzl", "JavaInfo", "JavaPluginInfo", "java_common")
+load("@com_google_protobuf//bazel/common:proto_common.bzl", "proto_common")
 
+# Proto toolchain type for accessing protoc via toolchain resolution.
+# This enables using prebuilt protoc when --@protobuf//bazel/toolchains:prefer_prebuilt_protoc is set.
+# See: https://github.com/grpc/grpc-java/issues/11152
+_PROTO_TOOLCHAIN_TYPE = Label("@com_google_protobuf//bazel/private:proto_toolchain_type")
+
+# Check if toolchain resolution is enabled (default true in Bazel 9+)
+_INCOMPATIBLE_TOOLCHAIN_RESOLUTION = proto_common.INCOMPATIBLE_ENABLE_PROTO_TOOLCHAIN_RESOLUTION
+
 _JavaRpcToolchainInfo = provider(
     fields = [
         "java_toolchain",
         "java_plugins",
         "plugin",
         "plugin_arg",
-        "protoc",
+        "protoc_files_to_run",  # FilesToRunProvider for protoc (prebuilt or compiled)
         "runtime",
     ],
 )
 
 def _java_rpc_toolchain_impl(ctx):
+    # Get protoc from proto toolchain (supports prebuilt protoc) or fallback to _protoc attribute
+    protoc_files_to_run = None
+    if _INCOMPATIBLE_TOOLCHAIN_RESOLUTION:
+        # With toolchain resolution enabled, get protoc from proto toolchain
+        toolchain = ctx.toolchains[_PROTO_TOOLCHAIN_TYPE]
+        if toolchain and hasattr(toolchain, "proto") and toolchain.proto:
+            proto_lang_toolchain = toolchain.proto
+            if hasattr(proto_lang_toolchain, "proto_compiler") and proto_lang_toolchain.proto_compiler:
+                protoc_files_to_run = proto_lang_toolchain.proto_compiler
+
+        if not protoc_files_to_run:
+            fail("Proto toolchain resolution is enabled but no proto_compiler found. " +
+                 "Ensure @protobuf//bazel/toolchains:prefer_prebuilt_protoc is set.")
+    else:
+        # Legacy: use _protoc attribute (compiled protoc)
+        protoc_files_to_run = ctx.attr._protoc[DefaultInfo].files_to_run
+
     return [
         _JavaRpcToolchainInfo(
             java_toolchain = ctx.attr._java_toolchain,
             java_plugins = ctx.attr.java_plugins,
             plugin = ctx.attr.plugin,
             plugin_arg = ctx.attr.plugin_arg,
-            protoc = ctx.attr._protoc,
+            protoc_files_to_run = protoc_files_to_run,
             runtime = ctx.attr.runtime,
         ),
         platform_common.ToolchainInfo(),  # Magic for b/78647825
     ]
+
+# Base attributes for java_rpc_toolchain
+_JAVA_RPC_TOOLCHAIN_ATTRS = {
+    # This attribute has a "magic" name recognized by the native DexArchiveAspect (b/78647825).
+    "runtime": attr.label_list(
+        cfg = "target",
+        providers = [JavaInfo],
+    ),
+    "plugin": attr.label(
+        cfg = "exec",
+        executable = True,
+    ),
+    "plugin_arg": attr.string(),
+    "java_plugins": attr.label_list(
+        default = [],
+        providers = [JavaPluginInfo],
+    ),
+    "_java_toolchain": attr.label(
+        default = Label("@bazel_tools//tools/jdk:current_java_toolchain"),
+    ),
+}
 
+# Legacy _protoc attribute - only included when toolchain resolution is disabled
+_LEGACY_PROTOC_ATTR = {
+    "_protoc": attr.label(
+        cfg = "exec",
+        default = Label("@com_google_protobuf//:protoc"),
+        executable = True,
+    ),
+}
+
+# Merge attributes based on toolchain resolution status
+# When toolchain resolution is enabled, we don't need _protoc (avoids compiling protoc from source)
+_FINAL_ATTRS = dict(_JAVA_RPC_TOOLCHAIN_ATTRS, **(_LEGACY_PROTOC_ATTR if not _INCOMPATIBLE_TOOLCHAIN_RESOLUTION else {}))
+
 java_rpc_toolchain = rule(
-    attrs = {
-        # This attribute has a "magic" name recognized by the native DexArchiveAspect (b/78647825).
-        "runtime": attr.label_list(
-            cfg = "target",
-            providers = [JavaInfo],
-        ),
-        "plugin": attr.label(
-            cfg = "exec",
-            executable = True,
-        ),
-        "plugin_arg": attr.string(),
-        "_protoc": attr.label(
-            cfg = "exec",
-            default = Label("@com_google_protobuf//:protoc"),
-            executable = True,
-        ),
-        "java_plugins": attr.label_list(
-            default = [],
-            providers = [JavaPluginInfo],
-        ),
-        "_java_toolchain": attr.label(
-            default = Label("@bazel_tools//tools/jdk:current_java_toolchain"),
-        ),
-    },
+    attrs = _FINAL_ATTRS,
+    toolchains = [config_common.toolchain_type(_PROTO_TOOLCHAIN_TYPE, mandatory = True)] if _INCOMPATIBLE_TOOLCHAIN_RESOLUTION else [],
     provides = [
         _JavaRpcToolchainInfo,
         platform_common.ToolchainInfo,
@@ -99,7 +137,7 @@
     ctx.actions.run(
         inputs = depset(srcs, transitive = [descriptor_set_in, toolchain.plugin[DefaultInfo].files]),
         outputs = [srcjar],
-        executable = toolchain.protoc[DefaultInfo].files_to_run,
+        executable = toolchain.protoc_files_to_run,
         arguments = [args],
         use_default_shell_env = True,
         toolchain = None,
