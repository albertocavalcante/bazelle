package kotlin

import (
	"regexp"
	"sort"
	"strings"
)

// Package-level compiled regexes for removeStringLiterals (performance optimization)
var (
	stringLiteralRegex = regexp.MustCompile(`"(?:[^"\\]|\\.)*"`)
	charLiteralRegex   = regexp.MustCompile(`'(?:[^'\\]|\\.)*'`)
)

// FQNScanner detects fully qualified names used inline without imports.
// This is useful for code generated by AI agents that may use FQN directly.
type FQNScanner struct {
	// Patterns for common package prefixes
	fqnPatterns []*regexp.Regexp

	// Pattern to detect type annotations and usages
	typeUsagePattern *regexp.Regexp

	// Pattern to detect function calls on FQN
	fqnCallPattern *regexp.Regexp

	// Known standard library packages to exclude
	stdlibPrefixes map[string]bool

	// Known Kotlin built-in types to exclude
	builtinTypes map[string]bool
}

// NewFQNScanner creates a new FQN scanner with default patterns.
func NewFQNScanner() *FQNScanner {
	s := &FQNScanner{
		stdlibPrefixes: map[string]bool{
			"kotlin":  true,
			"java":    true,
			"javax":   true,
			"android": true,
		},
		builtinTypes: map[string]bool{
			"String": true, "Int": true, "Long": true, "Short": true,
			"Byte": true, "Float": true, "Double": true, "Boolean": true,
			"Char": true, "Unit": true, "Nothing": true, "Any": true,
			"Array": true, "List": true, "Set": true, "Map": true,
			"MutableList": true, "MutableSet": true, "MutableMap": true,
			"Sequence": true, "Pair": true, "Triple": true,
			"Comparable": true, "Iterable": true, "Collection": true,
		},
	}

	// Common third-party package prefixes
	// Format: prefix.* where the next segment is lowercase (package) followed by uppercase (class)
	commonPrefixes := []string{
		"com", "org", "io", "net", "dev", "me", "app", "co",
		"kotlinx", "androidx", "ktor", "arrow", "koin",
		"dagger", "hilt", "retrofit", "okhttp", "gson", "moshi",
		"junit", "mockk", "kotest", "assertj", "hamcrest",
		"spring", "reactor", "coroutines", "flow",
	}

	// Build FQN patterns
	// Match: prefix.package.subpackage.ClassName
	// Where packages are lowercase and class name starts with uppercase
	for _, prefix := range commonPrefixes {
		// Pattern: prefix.lowercase.*(Uppercase word)
		// This matches things like: com.example.foo.Bar, org.junit.Test
		pattern := regexp.MustCompile(
			`\b` + regexp.QuoteMeta(prefix) + `\.` +
				`[a-z][a-zA-Z0-9_]*` + // First package segment (lowercase start)
				`(?:\.[a-z][a-zA-Z0-9_]*)*` + // More package segments
				`\.([A-Z][a-zA-Z0-9_]*)`, // Class name (uppercase start)
		)
		s.fqnPatterns = append(s.fqnPatterns, pattern)
	}

	// Generic FQN pattern for less common prefixes
	// Matches: any.package.path.ClassName where path has 2+ segments
	s.fqnPatterns = append(s.fqnPatterns, regexp.MustCompile(
		`\b([a-z][a-z0-9_]*(?:\.[a-z][a-z0-9_]*){2,}\.[A-Z][a-zA-Z0-9_]*)`,
	))

	// Type usage patterns (for : Type, as Type, is Type)
	s.typeUsagePattern = regexp.MustCompile(
		`(?::\s*|as\s+|is\s+)([a-z][a-z0-9_]*(?:\.[a-z][a-z0-9_]*)+\.[A-Z][a-zA-Z0-9_]*)`,
	)

	// Function/constructor call pattern: FQN()
	s.fqnCallPattern = regexp.MustCompile(
		`\b([a-z][a-z0-9_]*(?:\.[a-z][a-z0-9_]*)+\.[A-Z][a-zA-Z0-9_]*)\s*[(<]`,
	)

	return s
}

// ScanResult contains FQNs found in the code body.
type ScanResult struct {
	// FQNs is a list of fully qualified names found in the code.
	FQNs []string

	// FQNToLocations maps each FQN to line numbers where it was found.
	FQNToLocations map[string][]int
}

// Scan scans the code body for FQN usages.
// It takes the full file content and the line number where code starts (after imports).
func (s *FQNScanner) Scan(content string, codeStartLine int) *ScanResult {
	result := &ScanResult{
		FQNs:           make([]string, 0),
		FQNToLocations: make(map[string][]int),
	}

	lines := strings.Split(content, "\n")
	if codeStartLine < 0 || codeStartLine >= len(lines) {
		return result
	}

	fqnSet := make(map[string]bool)
	inMultilineComment := false
	tripleQuote := &tripleQuoteTracker{}

	for lineNum := codeStartLine; lineNum < len(lines); lineNum++ {
		line := lines[lineNum]

		// Track triple-quoted strings (must be done before other processing)
		wasInTripleQuote := tripleQuote.inTripleQuote
		isTripleQuoteLine := tripleQuote.processLine(line)
		if wasInTripleQuote && !strings.Contains(line, `"""`) {
			// We're inside a triple-quoted string block
			continue
		}
		if isTripleQuoteLine && !strings.Contains(line, `"""`) {
			continue
		}

		// Track multiline comments
		if strings.Contains(line, "/*") && !strings.Contains(line, "*/") {
			inMultilineComment = true
			continue
		}
		if strings.Contains(line, "*/") {
			inMultilineComment = false
			continue
		}
		if inMultilineComment {
			continue
		}

		// Skip lines that are just comments
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "//") {
			continue
		}

		// Remove single-line comments from the line
		if idx := strings.Index(line, "//"); idx >= 0 {
			line = line[:idx]
		}

		// Skip lines that are inside triple-quoted strings
		if tripleQuote.inTripleQuote {
			continue
		}

		// Remove string literals to avoid false positives
		line = removeStringLiterals(line)

		// Scan with all FQN patterns
		for _, pattern := range s.fqnPatterns {
			matches := pattern.FindAllStringSubmatch(line, -1)
			for _, match := range matches {
				fqn := match[0]
				if len(match) > 1 && match[1] != "" {
					// Some patterns capture just the class name in group 1
					// Use the full match (group 0) for the FQN
				}

				// Clean up the FQN
				fqn = cleanFQN(fqn)

				if s.shouldInclude(fqn) {
					if !fqnSet[fqn] {
						fqnSet[fqn] = true
						result.FQNs = append(result.FQNs, fqn)
					}
					result.FQNToLocations[fqn] = append(result.FQNToLocations[fqn], lineNum+1)
				}
			}
		}

		// Also scan with type usage pattern
		typeMatches := s.typeUsagePattern.FindAllStringSubmatch(line, -1)
		for _, match := range typeMatches {
			if len(match) > 1 {
				fqn := cleanFQN(match[1])
				if s.shouldInclude(fqn) {
					if !fqnSet[fqn] {
						fqnSet[fqn] = true
						result.FQNs = append(result.FQNs, fqn)
					}
					result.FQNToLocations[fqn] = append(result.FQNToLocations[fqn], lineNum+1)
				}
			}
		}

		// Scan for FQN function calls
		callMatches := s.fqnCallPattern.FindAllStringSubmatch(line, -1)
		for _, match := range callMatches {
			if len(match) > 1 {
				fqn := cleanFQN(match[1])
				if s.shouldInclude(fqn) {
					if !fqnSet[fqn] {
						fqnSet[fqn] = true
						result.FQNs = append(result.FQNs, fqn)
					}
					result.FQNToLocations[fqn] = append(result.FQNToLocations[fqn], lineNum+1)
				}
			}
		}
	}

	// Sort FQNs for deterministic output
	sort.Strings(result.FQNs)

	return result
}

// shouldInclude determines if an FQN should be included in results.
func (s *FQNScanner) shouldInclude(fqn string) bool {
	if fqn == "" {
		return false
	}

	// Must have at least 2 dots (package.subpackage.Class)
	if strings.Count(fqn, ".") < 2 {
		return false
	}

	// Extract the class name (last segment)
	parts := strings.Split(fqn, ".")
	className := parts[len(parts)-1]

	// Class name must start with uppercase
	if len(className) == 0 || className[0] < 'A' || className[0] > 'Z' {
		return false
	}

	// Exclude built-in types
	if s.builtinTypes[className] {
		return false
	}

	// Get the prefix (first segment)
	prefix := parts[0]

	// Include common third-party prefixes
	// Exclude kotlin/java stdlib (they're usually already on classpath)
	if s.stdlibPrefixes[prefix] {
		// Include kotlinx but not kotlin
		if prefix == "kotlinx" {
			return true
		}
		// Exclude standard library
		return false
	}

	return true
}

// cleanFQN removes any trailing characters that aren't part of the FQN.
func cleanFQN(fqn string) string {
	fqn = strings.TrimSpace(fqn)

	// Remove generic type parameters
	if idx := strings.Index(fqn, "<"); idx > 0 {
		fqn = fqn[:idx]
	}

	// Remove array brackets
	if idx := strings.Index(fqn, "["); idx > 0 {
		fqn = fqn[:idx]
	}

	// Remove nullable marker
	fqn = strings.TrimSuffix(fqn, "?")

	// Remove any trailing punctuation
	fqn = strings.TrimRight(fqn, ".,;:(){}[]<>?!")

	return fqn
}

// removeStringLiterals removes string content to avoid false FQN matches.
func removeStringLiterals(line string) string {
	// Remove regular strings (handles escaped quotes)
	result := stringLiteralRegex.ReplaceAllString(line, `""`)

	// Remove char literals
	result = charLiteralRegex.ReplaceAllString(result, `''`)

	return result
}

// isInTripleQuotedString checks if we're currently inside a triple-quoted string block.
// This is a simple state tracker - call it for each line.
type tripleQuoteTracker struct {
	inTripleQuote bool
}

func (t *tripleQuoteTracker) processLine(line string) bool {
	// Count triple quotes on this line
	count := strings.Count(line, `"""`)

	if count == 0 {
		return t.inTripleQuote
	}

	// Each pair of """ toggles the state
	for i := 0; i < count; i++ {
		t.inTripleQuote = !t.inTripleQuote
	}

	// If odd number of """, we're toggling state
	// Return true if we started in a triple quote or have an unclosed one
	return count%2 == 1 || t.inTripleQuote
}

// ExtractPackageFromFQN extracts the package portion from a fully qualified name.
// For example, "com.example.foo.Bar" returns "com.example.foo".
func ExtractPackageFromFQN(fqn string) string {
	if idx := strings.LastIndex(fqn, "."); idx > 0 {
		return fqn[:idx]
	}
	return ""
}

// ExtractClassFromFQN extracts the class name from a fully qualified name.
// For example, "com.example.foo.Bar" returns "Bar".
// Returns empty string for malformed FQNs like "com." or ".".
func ExtractClassFromFQN(fqn string) string {
	if idx := strings.LastIndex(fqn, "."); idx > 0 && idx < len(fqn)-1 {
		return fqn[idx+1:]
	}
	// Return empty for malformed FQNs (trailing dot, only dot, etc.)
	if strings.Contains(fqn, ".") {
		return ""
	}
	// No dot - return the FQN itself (simple class name)
	return fqn
}
